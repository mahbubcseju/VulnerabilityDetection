--------------------------------------------------------------------------------------------------------------------
Dataset id:  189
---------------------
Vulnerable function: 
int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
			    pte_t *dst_pte,
			    struct vm_area_struct *dst_vma,
			    unsigned long dst_addr,
			    unsigned long src_addr,
			    struct page **pagep)
{
	int vm_shared = dst_vma->vm_flags & VM_SHARED;
	struct hstate *h = hstate_vma(dst_vma);
	pte_t _dst_pte;
	spinlock_t *ptl;
	int ret;
	struct page *page;

	if (!*pagep) {
		ret = -ENOMEM;
		page = alloc_huge_page(dst_vma, dst_addr, 0);
		if (IS_ERR(page))
			goto out;

		ret = copy_huge_page_from_user(page,
						(const void __user *) src_addr,
						pages_per_huge_page(h), false);

		/* fallback to copy_from_user outside mmap_sem */
		if (unlikely(ret)) {
			ret = -EFAULT;
			*pagep = page;
			/* don't free the page */
			goto out;
		}
	} else {
		page = *pagep;
		*pagep = NULL;
	}

	/*
	 * The memory barrier inside __SetPageUptodate makes sure that
	 * preceding stores to the page contents become visible before
	 * the set_pte_at() write.
	 */
	__SetPageUptodate(page);
	set_page_huge_active(page);

	/*
	 * If shared, add to page cache
	 */
	if (vm_shared) {
		struct address_space *mapping = dst_vma->vm_file->f_mapping;
		pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);

		ret = huge_add_to_page_cache(page, mapping, idx);
		if (ret)
			goto out_release_nounlock;
	}

	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
	spin_lock(ptl);

	ret = -EEXIST;
	if (!huge_pte_none(huge_ptep_get(dst_pte)))
		goto out_release_unlock;

	if (vm_shared) {
		page_dup_rmap(page, true);
	} else {
		ClearPagePrivate(page);
		hugepage_add_new_anon_rmap(page, dst_vma, dst_addr);
	}

	_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);
	if (dst_vma->vm_flags & VM_WRITE)
		_dst_pte = huge_pte_mkdirty(_dst_pte);
	_dst_pte = pte_mkyoung(_dst_pte);

	set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);

	(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,
					dst_vma->vm_flags & VM_WRITE);
	hugetlb_count_add(pages_per_huge_page(h), dst_mm);

	/* No need to invalidate - it was non-present before */
	update_mmu_cache(dst_vma, dst_addr, dst_pte);

	spin_unlock(ptl);
	if (vm_shared)
		unlock_page(page);
	ret = 0;
out:
 	return ret;
 out_release_unlock:
 	spin_unlock(ptl);
out_release_nounlock:
 	if (vm_shared)
 		unlock_page(page);
 	put_page(page);
 	goto out;
 }

---------------------
Diff information:
{'92': 'out_release_nounlock:'}
---------------------
One of the slice that predicted as vulnerable: 
int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
pte_t *dst_pte,
struct vm_area_struct *dst_vma,
unsigned long dst_addr,
unsigned long src_addr,
struct page **pagep)
ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
spin_lock(ptl);
set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);
hugetlb_count_add(pages_per_huge_page(h), dst_mm);
spin_unlock(ptl);
out_release_nounlock:
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
Dataset id:  8369
---------------------
Vulnerable function: 
static int sp5x_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
                              AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    AVPacket avpkt_recoded;
    const int qscale = 5;
    const uint8_t *buf_ptr;
    uint8_t *recoded;
    int i = 0, j = 0;

    if (!avctx->width || !avctx->height)
        return -1;

    buf_ptr = buf;

    recoded = av_mallocz(buf_size + 1024);
    if (!recoded)
        return -1;

    /* SOI */
    recoded[j++] = 0xFF;
    recoded[j++] = 0xD8;

    memcpy(recoded+j, &sp5x_data_dqt[0], sizeof(sp5x_data_dqt));
    memcpy(recoded+j+5, &sp5x_quant_table[qscale * 2], 64);
    memcpy(recoded+j+70, &sp5x_quant_table[(qscale * 2) + 1], 64);
    j += sizeof(sp5x_data_dqt);

    memcpy(recoded+j, &sp5x_data_dht[0], sizeof(sp5x_data_dht));
    j += sizeof(sp5x_data_dht);

    memcpy(recoded+j, &sp5x_data_sof[0], sizeof(sp5x_data_sof));
    AV_WB16(recoded+j+5, avctx->coded_height);
    AV_WB16(recoded+j+7, avctx->coded_width);
    j += sizeof(sp5x_data_sof);

    memcpy(recoded+j, &sp5x_data_sos[0], sizeof(sp5x_data_sos));
    j += sizeof(sp5x_data_sos);

    if(avctx->codec_id==CODEC_ID_AMV)
        for (i = 2; i < buf_size-2 && j < buf_size+1024-2; i++)
            recoded[j++] = buf[i];
    else
    for (i = 14; i < buf_size && j < buf_size+1024-2; i++)
    {
        recoded[j++] = buf[i];
        if (buf[i] == 0xff)
            recoded[j++] = 0;
    }

    /* EOI */
    recoded[j++] = 0xFF;
    recoded[j++] = 0xD9;

    avctx->flags &= ~CODEC_FLAG_EMU_EDGE;
    av_init_packet(&avpkt_recoded);
    avpkt_recoded.data = recoded;
    avpkt_recoded.size = j;
    i = ff_mjpeg_decode_frame(avctx, data, data_size, &avpkt_recoded);

    av_free(recoded);

    return i;
}
---------------------
Diff information:
{'56': '    avctx->flags &= ~CODEC_FLAG_EMU_EDGE;'}
---------------------
One of the slice that predicted as vulnerable: 
static int sp5x_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt)
const uint8_t *buf = avpkt->data;
int buf_size = avpkt->size;
if (!avctx->width || !avctx->height)
buf_ptr = buf;
AV_WB16(recoded+j+5, avctx->coded_height);
AV_WB16(recoded+j+7, avctx->coded_width);
if(avctx->codec_id==CODEC_ID_AMV)
avctx->flags &= ~CODEC_FLAG_EMU_EDGE;
i = ff_mjpeg_decode_frame(avctx, data, data_size, &avpkt_recoded);
return i;
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
Dataset id:  5989
---------------------
Vulnerable function: 
void AutofillManager::GetAvailableSuggestions(
    const FormData& form,
    const FormFieldData& field,
    std::vector<Suggestion>* suggestions,
    SuggestionsContext* context) {
  DCHECK(suggestions);
  DCHECK(context);

  bool is_autofill_possible = RefreshDataModels();

  bool got_autofillable_form =
      GetCachedFormAndField(form, field, &context->form_structure,
                            &context->focused_field) &&
      context->form_structure->ShouldBeParsed();

  if (got_autofillable_form) {
    if (context->focused_field->Type().group() == CREDIT_CARD) {
      context->is_filling_credit_card = true;
      driver()->DidInteractWithCreditCardForm();
      credit_card_form_event_logger_->OnDidInteractWithAutofillableForm(
          context->form_structure->form_signature());
    } else {
      address_form_event_logger_->OnDidInteractWithAutofillableForm(
          context->form_structure->form_signature());
    }
  }

  context->is_context_secure =
      !IsFormNonSecure(form) ||
      !base::FeatureList::IsEnabled(
          features::kAutofillRequireSecureCreditCardContext);


  if (!is_autofill_possible || !driver()->RendererIsAvailable() ||
      !got_autofillable_form)
    return;

  context->is_autofill_available = true;

  if (context->is_filling_credit_card) {
    *suggestions =
        GetCreditCardSuggestions(field, context->focused_field->Type(),
                                 &context->is_all_server_suggestions);

    if (base::FeatureList::IsEnabled(kAutofillCreditCardAblationExperiment) &&
        !suggestions->empty()) {
      context->suppress_reason = SuppressReason::kCreditCardsAblation;
      suggestions->clear();
      return;
    }
  } else {
    if (!base::FeatureList::IsEnabled(kAutofillAlwaysFillAddresses) &&
        IsDesktopPlatform() && !field.should_autocomplete) {
      context->suppress_reason = SuppressReason::kAutocompleteOff;
      return;
    }

    *suggestions = GetProfileSuggestions(*context->form_structure, field,
                                         *context->focused_field);
  }

  if (!suggestions->empty() && context->is_filling_credit_card &&
      !context->is_context_secure) {
    Suggestion warning_suggestion(
        l10n_util::GetStringUTF16(IDS_AUTOFILL_WARNING_INSECURE_CONNECTION));
     warning_suggestion.frontend_id =
         POPUP_ITEM_ID_INSECURE_CONTEXT_PAYMENT_DISABLED_MESSAGE;
     suggestions->assign(1, warning_suggestion);
  } else {
    context->section_has_autofilled_field = SectionHasAutofilledField(
        *context->form_structure, form, context->focused_field->section);
    if (context->section_has_autofilled_field) {
      std::set<base::string16> seen_values;
      for (auto iter = suggestions->begin(); iter != suggestions->end();) {
        if (!seen_values.insert(iter->value).second) {
          iter = suggestions->erase(iter);
        } else {
          iter->label.clear();
          iter->icon.clear();
          ++iter;
        }
      }
    }
   }
 }

---------------------
Diff information:
{'68': '  } else {', '69': '    context->section_has_autofilled_field = SectionHasAutofilledField(', '70': '        *context->form_structure, form, context->focused_field->section);', '71': '    if (context->section_has_autofilled_field) {', '72': '      std::set<base::string16> seen_values;', '73': '      for (auto iter = suggestions->begin(); iter != suggestions->end();) {', '74': '        if (!seen_values.insert(iter->value).second) {', '75': '          iter = suggestions->erase(iter);', '76': '        } else {', '77': '          iter->label.clear();', '78': '          iter->icon.clear();', '79': '          ++iter;', '80': '        }', '81': '      }', '82': '    }'}
---------------------
One of the slice that predicted as vulnerable: 
void AutofillManager::GetAvailableSuggestions(
const FormData& form,
const FormFieldData& field,
std::vector<Suggestion>* suggestions,
SuggestionsContext* context) {
DCHECK(suggestions);
if (base::FeatureList::IsEnabled(kAutofillCreditCardAblationExperiment) &&
suggestions->clear();
*suggestions = GetProfileSuggestions(*context->form_structure, field,
if (!suggestions->empty() && context->is_filling_credit_card &&
suggestions->assign(1, warning_suggestion);
if (context->section_has_autofilled_field) {
for (auto iter = suggestions->begin(); iter != suggestions->end();) {
if (!seen_values.insert(iter->value).second) {
iter = suggestions->erase(iter);
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
Dataset id:  6309
---------------------
Vulnerable function: 
static void pci_indirect(void)
{
    QVirtioPCIDevice *dev;
    QPCIBus *bus;
    QVirtQueuePCI *vqpci;
    QGuestAllocator *alloc;
    QVirtioBlkReq req;
    QVRingIndirectDesc *indirect;
    void *addr;
    uint64_t req_addr;
    uint64_t capacity;
    uint32_t features;
    uint32_t free_head;
    uint8_t status;
    char *data;

    bus = test_start();

    dev = virtio_blk_init(bus);

    /* MSI-X is not enabled */
    addr = dev->addr + QVIRTIO_DEVICE_SPECIFIC_NO_MSIX;

    capacity = qvirtio_config_readq(&qvirtio_pci, &dev->vdev, addr);
    g_assert_cmpint(capacity, ==, TEST_IMAGE_SIZE / 512);

    features = qvirtio_get_features(&qvirtio_pci, &dev->vdev);
    g_assert_cmphex(features & QVIRTIO_F_RING_INDIRECT_DESC, !=, 0);
    features = features & ~(QVIRTIO_F_BAD_FEATURE | QVIRTIO_F_RING_EVENT_IDX |
                                                            QVIRTIO_BLK_F_SCSI);
    qvirtio_set_features(&qvirtio_pci, &dev->vdev, features);

    alloc = pc_alloc_init();
    vqpci = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,
                                                                    alloc, 0);
    qvirtio_set_driver_ok(&qvirtio_pci, &dev->vdev);

    /* Write request */
    req.type = QVIRTIO_BLK_T_OUT;
    req.ioprio = 1;
    req.sector = 0;
    req.data = g_malloc0(512);
    strcpy(req.data, "TEST");

    req_addr = virtio_blk_request(alloc, &req, 512);

    g_free(req.data);

    indirect = qvring_indirect_desc_setup(&dev->vdev, alloc, 2);
    qvring_indirect_desc_add(indirect, req_addr, 528, false);
    qvring_indirect_desc_add(indirect, req_addr + 528, 1, true);
    free_head = qvirtqueue_add_indirect(&vqpci->vq, indirect);
    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);

    g_assert(qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,
                                                        QVIRTIO_BLK_TIMEOUT));
    status = readb(req_addr + 528);
    g_assert_cmpint(status, ==, 0);

    g_free(indirect);
    guest_free(alloc, req_addr);

    /* Read request */
    req.type = QVIRTIO_BLK_T_IN;
    req.ioprio = 1;
    req.sector = 0;
    req.data = g_malloc0(512);
    strcpy(req.data, "TEST");

    req_addr = virtio_blk_request(alloc, &req, 512);

    g_free(req.data);

    indirect = qvring_indirect_desc_setup(&dev->vdev, alloc, 2);
    qvring_indirect_desc_add(indirect, req_addr, 16, false);
    qvring_indirect_desc_add(indirect, req_addr + 16, 513, true);
    free_head = qvirtqueue_add_indirect(&vqpci->vq, indirect);
    qvirtqueue_kick(&qvirtio_pci, &dev->vdev, &vqpci->vq, free_head);

    g_assert(qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,
                                                        QVIRTIO_BLK_TIMEOUT));
    status = readb(req_addr + 528);
    g_assert_cmpint(status, ==, 0);

    data = g_malloc0(512);
    memread(req_addr + 16, data, 512);
    g_assert_cmpstr(data, ==, "TEST");
    g_free(data);

    g_free(indirect);
    guest_free(alloc, req_addr);

    /* End test */
    guest_free(alloc, vqpci->vq.desc);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    test_end();
}
---------------------
Diff information:
{'54': '    g_assert(qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,', '55': '                                                        QVIRTIO_BLK_TIMEOUT));', '79': '    g_assert(qvirtio_wait_queue_isr(&qvirtio_pci, &dev->vdev, &vqpci->vq,', '80': '                                                        QVIRTIO_BLK_TIMEOUT));'}
---------------------
One of the slice that predicted as vulnerable: 
static void pci_indirect(void) 1
QVirtQueuePCI * vqpci ; 5
vqpci = ( QVirtQueuePCI * ) qvirtqueue_setup ( & qvirtio_pci , & dev -> vdev , alloc , 0 ); 34
free_head = qvirtqueue_add_indirect ( & vqpci -> vq , indirect ); 52
qvirtqueue_kick ( & qvirtio_pci , & dev -> vdev , & vqpci -> vq , free_head ); 53
g_assert ( qvirtio_wait_queue_isr ( & qvirtio_pci , & dev -> vdev , & vqpci -> vq , QVIRTIO_BLK_TIMEOUT ) ); 55
free_head = qvirtqueue_add_indirect ( & vqpci -> vq , indirect ); 77
qvirtqueue_kick ( & qvirtio_pci , & dev -> vdev , & vqpci -> vq , free_head ); 78
g_assert ( qvirtio_wait_queue_isr ( & qvirtio_pci , & dev -> vdev , & vqpci -> vq , QVIRTIO_BLK_TIMEOUT ) ); 80
guest_free ( alloc , vqpci -> vq . desc ); 94
--------------------------------------------------------------------------------------------------------------------
